// <auto-generated />
namespace Foundation
{
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    using System.Resources;

    /// <summary>
    ///		This API supports the Entity Framework Core infrastructure and is not intended to be used
    ///     directly from your code. This API may change or be removed in future releases.
    /// </summary>
    public static partial class ResX
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Foundation.Properties.ResX", typeof(ResX).GetTypeInfo().Assembly);

        /// <summary>
        /// The string argument '{argumentName}' cannot be empty.
        /// </summary>
        public static string ArgumentIsEmpty(object argumentName)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ArgumentIsEmpty", "argumentName"), argumentName);
        }

        /// <summary>
        /// The property '{property}' of the argument '{argument}' cannot be null.
        /// </summary>
        public static string ArgumentPropertyNull(object property, object argument)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("ArgumentPropertyNull", "property", "argument"), property, argument);
        }

        /// <summary>
        /// The collection argument '{argumentName}' must contain at least one element.
        /// </summary>
        public static string CollectionArgumentIsEmpty(object argumentName)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("CollectionArgumentIsEmpty", "argumentName"), argumentName);
        }

        /// <summary>
        /// A key cannot be configured on '{derivedType}' because it is a derived type. The key must be configured on the root type '{rootType}'.
        /// </summary>
        public static string DerivedEntityKey(object derivedType, object rootType)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("DerivedEntityKey", "derivedType", "rootType"), derivedType, rootType);
        }

        /// <summary>
        /// The annotation '{annotation}' cannot be added because an annotation with the same name already exists.
        /// </summary>
        public static string DuplicateAnnotation(object annotation)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("DuplicateAnnotation", "annotation"), annotation);
        }

        /// <summary>
        /// The entity '{entity}' cannot be added to the model because an entity with the same name already exists.
        /// </summary>
        public static string DuplicateEntity(object entity)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("DuplicateEntity", "entity"), entity);
        }

        /// <summary>
        /// The key {key} cannot be added to the entity type '{entityType}' because a key on the same properties already exists on entity type '{duplicateEntityType}'.
        /// </summary>
        public static string DuplicateKey(object key, object entityType, object duplicateEntityType)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("DuplicateKey", "key", "entityType", "duplicateEntityType"), key, entityType, duplicateEntityType);
        }

        /// <summary>
        /// The base entity cannot be added to the entity because a base entity is already defined.
        /// </summary>
        public static string EntityBaseTypeAlreadyDefined
        {
            get { return GetString("EntityBaseTypeAlreadyDefined"); }
        }

        /// <summary>
        /// Une clé primaire existe déjà.
        /// </summary>
        public static string EntityKeyAlreadyExists
        {
            get { return GetString("EntityKeyAlreadyExists"); }
        }

        /// <summary>
        /// Navigation and inverse properties must define the same association table name.
        /// </summary>
        public static string IncoherentAssociationTableNames
        {
            get { return GetString("IncoherentAssociationTableNames"); }
        }

        /// <summary>
        /// The specified key properties {key} are not declared on the entity type '{entityType}'. Ensure key properties are declared on the target entity type.
        /// </summary>
        public static string KeyPropertiesWrongEntity(object key, object entityType)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("KeyPropertiesWrongEntity", "key", "entityType"), key, entityType);
        }

        /// <summary>
        /// The property '{property}' cannot be part of a key on '{entityType}' because it is contained in a foreign key defined on a derived entity type.
        /// </summary>
        public static string KeyPropertyInForeignKey(object property, object entityType)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("KeyPropertyInForeignKey", "property", "entityType"), property, entityType);
        }

        /// <summary>
        /// A key on entity type '{entityType}' cannot contain the property '{property}' because it is nullable/optional. All properties on which a key is declared must be marked as non-nullable/required.
        /// </summary>
        public static string NullableKey(object entityType, object property)
        {
            return string.Format(CultureInfo.CurrentCulture, GetString("NullableKey", "entityType", "property"), entityType, property);
        }

        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name);

            Debug.Assert(value != null);

            if (formatterNames != null)
            {
                for (var i = 0; i < formatterNames.Length; i++)
                {
                    value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
                }
            }

            return value;
        }
    }
}
